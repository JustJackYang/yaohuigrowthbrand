import { Solar, Lunar, EightChar } from 'lunar-javascript';

// Equation of Time approximation (minutes)
function getEquationOfTime(d) {
  const dayOfYear = Math.floor((d.getTime() - new Date(d.getFullYear(), 0, 0).getTime()) / 86400000);
  const b = (2 * Math.PI * (dayOfYear - 81)) / 365;
  return 9.87 * Math.sin(2 * b) - 7.53 * Math.cos(b) - 1.5 * Math.sin(b);
}

export function calculateBazi(
  dateStr, // YYYY-MM-DD HH:mm
  longitude = 120 // Default to Beijing/Hangzhou longitude if not provided
) {
  const date = new Date(dateStr);
  
  // 1. Calculate True Solar Time
  // Beijing Time is UTC+8 (120 degrees east)
  // Time difference = (Longitude - 120) * 4 minutes
  const longitudeDiffMinutes = (longitude - 120) * 4;
  
  // Equation of Time correction
  const eotMinutes = getEquationOfTime(date);
  
  const totalCorrectionMinutes = longitudeDiffMinutes + eotMinutes;
  
  // Apply correction
  const solarTimeDate = new Date(date.getTime() + totalCorrectionMinutes * 60000);
  
  const solar = Solar.fromDate(solarTimeDate);
  const lunar = solar.getLunar();
  const eightChar = lunar.getEightChar();
  
  // 2. Get Four Pillars
  const yearGanZhi = eightChar.getYear();
  const monthGanZhi = eightChar.getMonth();
  const dayGanZhi = eightChar.getDay();
  const hourGanZhi = eightChar.getTime();
  
  // 3. Analyze Elements (Simplified)
  const dayMaster = dayGanZhi.substring(0, 1); // The Heavenly Stem of Day
  
  // Count elements in the 4 pillars (Stem and Branch main qi)
  // This is a simplified counting. Real BaZi is complex.
  // We use lunar-javascript's WuXing for Stems and Branches
  
  const wuxingCount = {
    '金': 0, '木': 0, '水': 0, '火': 0, '土': 0
  };
  
  // Helper to add wuxing
  const addWuxing = (char) => {
    // Basic mapping for Stems and Branches to Wuxing
    // Stems
    if ('甲乙'.includes(char)) wuxingCount['木']++;
    else if ('丙丁'.includes(char)) wuxingCount['火']++;
    else if ('戊己'.includes(char)) wuxingCount['土']++;
    else if ('庚辛'.includes(char)) wuxingCount['金']++;
    else if ('壬癸'.includes(char)) wuxingCount['水']++;
    
    // Branches
    else if ('寅卯'.includes(char)) wuxingCount['木']++;
    else if ('巳午'.includes(char)) wuxingCount['火']++;
    else if ('申酉'.includes(char)) wuxingCount['金']++;
    else if ('亥子'.includes(char)) wuxingCount['水']++;
    else if ('辰戌丑未'.includes(char)) wuxingCount['土']++;
  };
  
  [yearGanZhi, monthGanZhi, dayGanZhi, hourGanZhi].forEach(gz => {
    addWuxing(gz[0]); // Stem
    addWuxing(gz[1]); // Branch
  });
  
  // 4. Determine Strength (Heuristic V1.0)
  const dmChar = dayGanZhi.substring(0, 1);
  const monthBranch = monthGanZhi.substring(1, 2);
  
  const wuxingMap = {
      '甲': '木', '乙': '木', '丙': '火', '丁': '火', '戊': '土', 
      '己': '土', '庚': '金', '辛': '金', '壬': '水', '癸': '水',
      '寅': '木', '卯': '木', '辰': '土', '巳': '火', '午': '火', 
      '未': '土', '申': '金', '酉': '金', '戌': '土', '亥': '水', 
      '子': '水', '丑': '土'
  };

  const dmWx = wuxingMap[dmChar];
  const monthWx = wuxingMap[monthBranch];
  
  // Generating Cycle: 木->火->土->金->水->木
  const generating = { '木': '火', '火': '土', '土': '金', '金': '水', '水': '木' };
  // Controlling Cycle: 木->土->水->火->金->木
  const controlling = { '木': '土', '土': '水', '水': '火', '火': '金', '金': '木' };
  
  // Determine Strength based on Season (Month Branch)
  // Simplified: If Month Wuxing is Same or Generating DM, then Strong.
  let isStrong = false;
  if (dmWx === monthWx || generating[monthWx] === dmWx) {
      isStrong = true;
  }
  
  // Determine Favorable Elements (Xiyongshen)
  const xiyongshen = [];
  
  if (!isStrong) { // Weak
      // Need Resource (Generating DM)
      const resource = Object.keys(generating).find(key => generating[key] === dmWx);
      if (resource) xiyongshen.push(resource);
      // Need Companion (Same as DM)
      xiyongshen.push(dmWx);
  } else { // Strong
      // Need Wealth (Controlled by DM)
      xiyongshen.push(controlling[dmWx]);
      // Need Officer (Controlling DM)
      const officer = Object.keys(controlling).find(key => controlling[key] === dmWx);
      if (officer) xiyongshen.push(officer);
      // Need Output (Generated by DM)
      xiyongshen.push(generating[dmWx]);
  }
  
  if (xiyongshen.length === 0) {
      xiyongshen.push('土', '金');
  }

  // Determine Suggestions (Balanced Supplement)
  // Filter out elements that are already too strong in the chart (Count >= 3)
  const suggestions = xiyongshen.filter(wx => {
      return (wuxingCount[wx] || 0) < 3;
  });
  
  // Fallback: If all favorable elements are already strong (unlikely but possible), 
  // suggest the one with the lowest count among favorable elements.
  if (suggestions.length === 0) {
      const sorted = xiyongshen.sort((a, b) => (wuxingCount[a] || 0) - (wuxingCount[b] || 0));
      suggestions.push(sorted[0]);
  }

  const strongOrWeak = isStrong ? '身旺' : '身弱';

  return {
    solarTime: solarTimeDate.toISOString().replace('T', ' ').substring(0, 16),
    lunarDate: lunar.toString(),
    bazi: {
      year: yearGanZhi,
      month: monthGanZhi,
      day: dayGanZhi,
      hour: hourGanZhi
    },
    dayMaster: dmChar + `(${dmWx})`,
    wuxing: wuxingCount,
    strongOrWeak,
    favorable: suggestions, // Use the balanced suggestions for name generation
    xiyongshen: xiyongshen // Keep the theoretical Xiyongshen for display
  };
}
